{"version":3,"sources":["tetrisConfig.ts","tetrominos.ts","Components/Cell.tsx","Components/Stage.tsx","gameHelpers.ts","Hooks/usePlayer.ts","Hooks/useStage.ts","Hooks/useInterval.ts","Components/Tetris.tsx","Hooks/useGameStatus.ts","App.tsx","index.tsx"],"names":["tetrisConfig","width","height","backgroundColor","lineColor","size","spacing","TETROMINOS","0","shape","color","I","J","L","O","S","T","Z","randomTetromino","tetrominos","randTetromino","Math","floor","random","length","StyledCube","styled","div","transparent","StyledCubeFace","face","handleFaceTransform","Cell","props","StyledStage","StyledRow","Stage","stage","map","row","rowIndex","index","type","createStage","Array","from","fill","checkCollision","player","moveX","x","moveY","y","tetromino","pos","playerStartingState","collided","useStage","resetPlayer","useState","setStage","rowsCleared","setRowsCleared","useEffect","updateStage","prevStage","newStage","cell","forEach","value","newY","newX","reduce","accumulator","findIndex","prev","unshift","push","sweepRows","prevState","useInterval","callback","delay","savedCallback","useRef","current","interval","setInterval","clearInterval","StyledTetrisContainer","StyledControlsContainer","StyledScoreBoard","StyledButton","button","Tetris","dropTime","setDropTime","gameOver","setGameOver","gamePaused","setGamePaused","gameStarted","setGameStarted","setPlayer","rotate","matrix","direction","rotatedTetromino","_","col","reverse","useCallback","clonedPlayer","JSON","parse","stringify","offset","usePlayer","updatePlayerPosition","playerRotate","score","setScore","rows","setRows","level","setLevel","linePoints","calcScore","useGameStatus","movePlayer","dir","drop","console","log","move","keyCode","role","tabIndex","onKeyUp","onKeyDown","event","preventDefault","onClick","StyledApp","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f2bc731d.chunk.js","sourcesContent":["export const tetrisConfig = {\n    stage: {\n        width: 8,\n        height: 16,\n        backgroundColor: 'transparent',\n        lineColor: '#000',\n    },\n    cell: {\n        size: 38,\n        spacing: 0,\n    }\n}","export type TetrominoShapeType = Array<Array<string | number>>;\n\nexport type TetrominoKeyType = 0 | \"I\" | \"J\" | \"L\" | \"O\" | \"S\" | \"T\" | \"Z\";\n\nexport type TetrominoType = {\n    shape: TetrominoShapeType;\n    color: string;\n}\n\nexport type TetrominosType = {\n    [key in TetrominoKeyType]: TetrominoType;\n};\n\nexport const TETROMINOS: TetrominosType = {\n    0: { shape: [[0]], color: '0, 0, 0' },\n    I: {\n        shape: [[0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0]],\n        color: '#EBA83A',\n    },\n    J: {\n        shape: [[0, 'J', 0], [0, 'J', 0], ['J', 'J', 0]],\n        color: '#E4BAD4',\n    },\n    L: {\n        shape: [[0, 'L', 0], [0, 'L', 0], [0, 'L', 'L']],\n        color: '#FFC074',\n    },\n    O: {\n        shape: [['O', 'O'], ['O', 'O']],\n        color: '#FAEBE0',\n    },\n    S: {\n        shape: [[0, 'S', 'S'], ['S', 'S', 0], [0, 0, 0]],\n        color: '#F7E6AD',\n    },\n    T: {\n        shape: [[0, 0, 0], ['T', 'T', 'T'], [0, 'T', 0]],\n        color: '#C9D8B6',\n    },\n    Z: {\n        shape: [['Z', 'Z', 0], [0, 'Z', 'Z'], [0, 0, 0]],\n        color: '#F1ECC3',\n    },\n};\n  \nexport const randomTetromino = () => {\n    const tetrominos = 'IJLOSTZ';\n    const randTetromino = tetrominos[Math.floor(Math.random() * tetrominos.length)];\n    return TETROMINOS[randTetromino as keyof TetrominosType];\n};","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../tetrisConfig';\n\ntype PropsType = {\n    color: string;\n}\n\nconst handleFaceTransform = (face: string) => {\n    switch (face) {\n        case \"right\": return 'rotateY(90deg)';\n        case \"back\": return 'rotateY(180deg)';\n        case \"left\": return 'rotateY(-90deg)';\n        case \"top\": return 'rotateX(90deg)';\n        case \"bottom\": return 'rotateX(-90deg)';\n        default: case \"front\": return 'rotateY(0deg)';\n    }\n};\n\nconst StyledCube = styled.div<{ transparent?: boolean }>`\n    width: ${tetrisConfig.cell.size}px;\n    height: ${tetrisConfig.cell.size}px;\n    position: relative;\n    transform-style: preserve-3d;\n    transform:  translateX(${tetrisConfig.cell.spacing / 2}px) translateY(${tetrisConfig.cell.spacing / 2}px) translateZ(${tetrisConfig.cell.size}px);\n    transition: transform 1s;\n    \n    ${({transparent}) => !transparent && `\n        &::after {\n            content: '';\n            position: absolute;\n            width: ${tetrisConfig.cell.size}px;\n            height: ${tetrisConfig.cell.size}px;\n            background: rgba(0,0,0,.1);\n            box-shadow: 0 0 10px rgba(0,0,0,.1);\n            transform: translateZ(-${tetrisConfig.cell.size}px);\n        }\n    `}\n`\n\nconst StyledCubeFace = styled.div<{ face: string; color: string; }>`\n    position: absolute;\n    width: ${tetrisConfig.cell.size - (tetrisConfig.cell.spacing * 2)}px;\n    height: ${tetrisConfig.cell.size - (tetrisConfig.cell.spacing * 2)}px;\n    background: ${({color}) => color};\n    line-height: ${tetrisConfig.cell.size}px;\n    font-size: 40px;\n    font-weight: bold;\n    color: white;\n    text-align: center;\n    box-shadow: 0 0 0 1px rgba(0,0,0,.1) inset;\n    transform: ${({ face }) => `${handleFaceTransform(face)} translateZ(${(tetrisConfig.cell.size / 2) - (tetrisConfig.cell.spacing)}px)`};\n`;\n\nconst Cell:FC<PropsType> = props => {\n    if (props.color === 'transparent') {\n        return <StyledCube transparent />\n    }\n\n    return (\n        <StyledCube>\n            <StyledCubeFace face=\"front\" color={props.color} />\n            <StyledCubeFace face=\"back\" color={props.color} />\n            <StyledCubeFace face=\"right\" color={props.color} />\n            <StyledCubeFace face=\"left\" color={props.color} />\n            <StyledCubeFace face=\"top\" color={props.color} />\n            <StyledCubeFace face=\"bottom\" color={props.color} />\n        </StyledCube>\n    )\n}\n\nexport default Cell;","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../tetrisConfig';\nimport { TETROMINOS, TetrominosType } from '../tetrominos';\nimport Cell from './Cell';\n\nconst StyledStage = styled.div`\n    width: ${() => `${tetrisConfig.stage.width * tetrisConfig.cell.size}px`};\n    height: ${() => `${tetrisConfig.stage.height * tetrisConfig.cell.size}px`};\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: flex-end;\n    align-items: flex-end;\n    background: ${tetrisConfig.stage.backgroundColor};\n    background-image: \n        linear-gradient(${tetrisConfig.stage.lineColor} 1px, transparent 1px),\n        linear-gradient(90deg, ${tetrisConfig.stage.lineColor} 1px, transparent 1px);\n    background-size: ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px, ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px;\n    background-position: -1px -1px, -1px -1px;\n    box-shadow: 0 0 0 1px ${tetrisConfig.stage.lineColor} inset;\n`\n\nconst StyledRow = styled.div`\n    display: flex;\n    height: ${tetrisConfig.cell.size}px;\n    width: 100%;\n`;\n\ntype PropsType = {\n    stage: any;\n}\n\nconst Stage:FC<PropsType> = props => {\n    return (\n        <StyledStage>\n            {props.stage.map((row: Array<Array<any>>, rowIndex: number) => (\n                <StyledRow key={rowIndex}>\n                    {row.map(([type, state], index: number) => {\n                        return <Cell key={rowIndex + index} color={type === 0 ? \"transparent\": TETROMINOS[type as keyof TetrominosType].color} />\n                    })}\n                </StyledRow>\n            ))}\n        </StyledStage>\n    )\n}\n\nexport default Stage;","import { tetrisConfig } from './tetrisConfig';\nimport { TetrominoShapeType } from './tetrominos';\n\nexport type StageCellType = [ TetrominoShapeType]\n\nexport type StageType = Array<Array<any>>;\n\nexport const createStage = (): StageType => {\n    const emptyStage = Array.from(Array(tetrisConfig.stage.height), () =>\n            new Array(tetrisConfig.stage.width).fill([0, 'clear']),\n    );\n\n    return emptyStage;\n}\n\nexport const checkCollision = (player: any, stage: any, { x: moveX, y: moveY }: { x: number, y: number}) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // We shouldn't go through the bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n          // 4. Check that the cell wer'e moving to isn't set to clear\n          stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n            'clear'\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n};","import { useCallback, useState } from 'react';\nimport { checkCollision, StageType } from '../gameHelpers';\nimport { tetrisConfig } from '../tetrisConfig';\nimport { randomTetromino, TETROMINOS, TetrominoShapeType } from '../tetrominos';\n\nexport type PositionType = { \n    x: number; \n    y: number;\n}\n\nexport type PlayerStateType = {\n    pos: PositionType;\n    tetromino: TetrominoShapeType;\n    collided: boolean;\n}\n\nexport type PlayerPositionType = PositionType & { collided: boolean; }\n\nconst playerStartingState: PlayerStateType = {\n    pos: { \n        x: 0, \n        y: 0 \n    },\n    tetromino: TETROMINOS[0].shape,\n    collided: false,\n};\n\nexport const usePlayer = () => {\n    const [ player, setPlayer ] = useState(playerStartingState);\n\n    const rotate = (matrix: TetrominoShapeType, direction: number) => {\n        const rotatedTetromino = matrix.map((_, index) => \n            matrix.map(col => col[index]),\n        );\n\n        if (direction > 0) return rotatedTetromino.map(row => row.reverse());\n\n        return rotatedTetromino.reverse();\n    }\n\n    const playerRotate = (stage: StageType, direction: number) => {\n        const clonedPlayer = JSON.parse(JSON.stringify(player));\n        clonedPlayer.tetromino = rotate(clonedPlayer.tetromino, direction);\n\n        const pos = clonedPlayer.pos.x;\n        let offset = 1;\n        while (checkCollision(clonedPlayer, stage, { x: 0, y: 0 })) {\n            clonedPlayer.pos.x += offset;\n            offset = -(offset + (offset > 0 ? 1 : -1));\n            if (offset > clonedPlayer.tetromino[0].length) {\n                rotate(clonedPlayer.tetromino, -direction);\n                clonedPlayer.pos.x = pos;\n                return;\n            }\n        }\n        setPlayer(clonedPlayer);\n    }\n\n    const updatePlayerPosition = ({ x, y, collided} : PlayerPositionType) => {\n        setPlayer(prev => ({\n            ...prev,\n            pos: { \n                x: prev.pos.x += x, \n                y: prev.pos.y += y \n            },\n            collided,\n        }))\n    }\n\n    const resetPlayer = useCallback(() => {\n        setPlayer({\n            pos: { \n                x: (tetrisConfig.stage.width / 2) - 2, \n                y: 0 \n            },\n            tetromino: randomTetromino().shape,\n            collided: false, \n        })\n    }, []);\n\n    return [ player, updatePlayerPosition, resetPlayer, playerRotate ] as const;\n}","import { useState, useEffect } from 'react';\nimport { createStage, StageType } from '../gameHelpers';\nimport { PlayerStateType } from './usePlayer';\n\nexport const useStage = (player: PlayerStateType, resetPlayer: any) => {\n    const [ stage, setStage ] = useState(createStage());\n    const [ rowsCleared, setRowsCleared ] = useState(0);\n\n    useEffect(() => {\n        setRowsCleared(0);\n\n        const sweepRows = (newStage: StageType) => (\n            newStage.reduce((accumulator, row) => {\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\n                    setRowsCleared(prev => prev + 1);\n                    accumulator.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n\n                    return accumulator;\n                }\n\n                accumulator.push(row);\n\n                return accumulator;\n            }, [])\n        )\n\n        const updateStage = (prevStage: StageType): StageType => {\n            const newStage = prevStage.map(row => {\n                return row.map(cell => { return cell[1] === 'clear' ? [0, 'clear'] : cell })\n            });\n\n            // draw the current tetromino\n            player.tetromino.forEach((row, y: number) => {\n                row.forEach((value: number | string, x: number) => {\n                    if (value !== 0) {\n                        const newY = y + player.pos.y;\n                        const newX = x + player.pos.x;\n\n                        newStage[newY][newX] = [\n                            value,\n                            player.collided ? 'merged' : 'clear',\n                        ];\n                    }\n                });\n            });\n\n            // check collisions\n            if (player.collided) {\n                resetPlayer();\n\n                return sweepRows(newStage);\n            }\n\n            return newStage;\n        }\n\n        setStage(prevState => updateStage(prevState));\n\n    }, [player, resetPlayer]);\n\n    return [ stage, setStage, rowsCleared ] as const;\n};","import { useEffect, useRef } from 'react';\n\nconst useInterval = (callback: Function, delay?: number | null) => {\n    const savedCallback = useRef<Function>(() => {});\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    });\n\n    useEffect(() => {\n        if (delay !== null) {\n        const interval = setInterval(() => savedCallback.current(), delay || 0);\n            return () => clearInterval(interval);\n        }\n\n        return undefined;\n    }, [delay]);\n};\n\nexport default useInterval;\n","import React, { useState } from 'react';\nimport Stage from './Stage';\nimport { usePlayer } from '../Hooks/usePlayer';\nimport { useStage } from '../Hooks/useStage';\nimport useInterval from '../Hooks/useInterval';\nimport styled from 'styled-components';\nimport { createStage, checkCollision } from '../gameHelpers';\nimport { useGameStatus } from '../Hooks/useGameStatus';\n\nconst StyledTetrisContainer = styled.div`\n    height: 100vh;\n    outline: none;\n    display: flex;\n    flex-flow: row nowrap;\n    transform-style: preserve-3d;\n    transform: rotateX(35deg) rotateY(0deg) translateZ(100px);\n`;\n\nconst StyledControlsContainer = styled.div`\n    width: 200px;\n    margin-right: 20px;\n    display: flex;\n    flex-flow: column wrap;\n    justify-content: flex-start;\n    align-items: stretch;\n`;\n\nconst StyledScoreBoard = styled.div`\n    border: 2px solid #000;\n    border-radius: 8px;\n    line-height: 40px;\n    font-size: 20px;\n    background: #FFF;\n    margin-top: 20px;\n    color: #000;\n    text-align: center;\n`;\n\nconst StyledButton = styled.button`\n    outline: none;\n    border: 2px solid #000;\n    border-radius: 8px;\n    line-height: 40px;\n    font-size: 20px;\n    background: #FFF;\n\n    &:hover {\n        cursor: pointer;\n        box-shadow: 0 0 20px rgba(0,0,0,.2);\n    }\n`;\n\nconst Tetris = () => {\n    const [ dropTime, setDropTime ] = useState<null | number>(null);\n    const [ gameOver, setGameOver ] = useState(false);\n    const [ gamePaused, setGamePaused ] = useState(false);\n    const [ gameStarted, setGameStarted ] = useState(false);\n    const [ player, updatePlayerPosition, resetPlayer, playerRotate ] = usePlayer();\n    const [ stage, setStage, rowsCleared ] = useStage(player, resetPlayer);\n    const [score, setScore, rows, setRows, level, setLevel] = useGameStatus(rowsCleared);\n    \n    const movePlayer = (dir: number) => {\n        if (!checkCollision(player, stage, { x: dir, y: 0 })) {\n            updatePlayerPosition({ x: dir, y: 0, collided: false });\n        }\n    }\n\n    const startGame = () => {\n        setStage(createStage());\n        setDropTime(1000);\n        resetPlayer();\n        setScore(0);\n        setLevel(0);\n        setRows(0);\n        setGameOver(false);\n        setGameStarted(true);\n    }\n\n    const drop = () => {\n        // Increase level and speed when player has cleared 10 rows\n        if (rows > (level + 1) * 10) {\n            setLevel(prev => prev + 1);\n            setDropTime(1000 / (level + 1) + 200);\n        }\n\n        if (!checkCollision(player, stage, { x: 0, y: 1 })) {\n            updatePlayerPosition({ x: 0, y: 1, collided: false });\n        } else {\n            if (player.pos.y < 1) {\n                console.log('GAME OVER');\n                setGameOver(true);\n                setDropTime(null);\n            }\n            updatePlayerPosition({ x: 0, y: 0, collided: true });\n        }\n    }\n\n    const pauseGame = () => {\n        setGamePaused(true);\n        setDropTime(null);\n    }\n\n    const continueGame = () => {\n        setGamePaused(false);\n        setDropTime(1000 / (level + 1));\n    };\n\n    const keyUp = ({ keyCode }: { keyCode: number}) => {\n        if (!gameOver && keyCode === 40) {\n            setDropTime(1000 / (level + 1));\n        }\n    }\n\n    const dropPlayer = () => {\n        setDropTime(null);\n        drop(); \n    }\n\n\n    const move = ({ keyCode } : { keyCode: number}) => {\n        if (!gameOver) {\n            switch (keyCode) {\n                case 37: movePlayer(-1); break;\n                case 39: movePlayer(1); break;\n                case 40: dropPlayer(); break;\n                case 38: playerRotate(stage, 1); break;\n            }\n        }\n    }\n\n    useInterval(() => {\n        drop();\n    }, dropTime);\n\n    return (\n        <StyledTetrisContainer role=\"button\" tabIndex={0} onKeyUp={keyUp} onKeyDown={event => { \n            move(event); \n            event.preventDefault(); \n        }}>\n            <StyledControlsContainer>\n                {!gameStarted ? (\n                    <StyledButton onClick={() => { startGame(); }}>Start Game</StyledButton>\n                ) : (\n                    <StyledButton onClick={() => { gamePaused ? continueGame() : pauseGame() }}>\n                        {gamePaused ? 'Continue Game' : 'Pause Game'}\n                    </StyledButton>\n                )}\n                <StyledScoreBoard>Score: {score}</StyledScoreBoard>\n                <StyledScoreBoard>Rows: {rows}</StyledScoreBoard>\n                <StyledScoreBoard>Level: {level}</StyledScoreBoard>\n            </StyledControlsContainer>\n            <Stage stage={stage} />\n        </StyledTetrisContainer>\n    )\n}\n\nexport default Tetris;\n","import { useState, useEffect, useCallback } from 'react';\n\nexport const useGameStatus = (rowsCleared: number) => {\n    const [score, setScore] = useState(0);\n    const [rows, setRows] = useState(0);\n    const [level, setLevel] = useState(0);\n\n    const linePoints = [40, 100, 300, 1200];\n\n    const calcScore = useCallback(() => {\n        if (rowsCleared > 0) {\n            // This is how original Tetris score is calculated\n            setScore(prev => prev + linePoints[rowsCleared - 1] * (level + 1));\n            setRows(prev => prev + rowsCleared);\n        }\n    }, [level, linePoints, rowsCleared]);\n\n    useEffect(() => {\n        calcScore();\n    }, [calcScore, rowsCleared, score]);\n\n    return [score, setScore, rows, setRows, level, setLevel] as const;\n};\n","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport Tetris from './Components/Tetris';\n\nconst StyledApp = styled.div`\n    margin: 0;\n    font-family: 'Segoe UI', sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    color: #db7093;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    perspective: 1000px;\n`;\n\nconst StyledHeader = styled.div`\n    font-size: calc(10px + 2vmin);\n`;\n\nconst App:FC = () => {\n  return (\n    <StyledApp>\n      <Tetris />\n    </StyledApp>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}
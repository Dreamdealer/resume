{"version":3,"sources":["Config/tetrisConfig.ts","Config/tetrominos.ts","Components/Cell.tsx","Components/Instructions.tsx","Components/Stage.tsx","gameHelpers.ts","Hooks/usePlayer.ts","Hooks/useStage.ts","Hooks/useInterval.ts","Components/Display.tsx","Components/Button.tsx","Components/GameOver.tsx","Components/Styles.ts","Components/OnScreenControls.tsx","Components/Tetris.tsx","Hooks/useGameStatus.ts","index.tsx"],"names":["tetrisConfig","width","height","backgroundColor","lineColor","guideColor","size","spacing","TETROMINOS","0","shape","color","I","J","L","O","S","T","Z","randomTetromino","tetrominos","randTetromino","Math","floor","random","length","StyledCube","styled","div","transparent","StyledCubeFace","face","handleFaceTransform","Cell","props","StyledInstructions","Instructions","StyledStage","showInstructions","paused","StyledPause","StyledRow","StyledColumnGuide","left","columnWidth","Stage","activeColumns","stage","map","row","rowIndex","index","type","createStage","Array","from","fill","checkCollision","player","moveX","x","moveY","y","tetromino","pos","playerStartingState","collided","useStage","resetPlayer","useState","setStage","rowsCleared","setRowsCleared","setActiveColumns","useEffect","updateStage","prevStage","newStage","cell","offsetArray","indexes","filter","min","max","cells","flat","forEach","value","newY","newX","reduce","accumulator","findIndex","prev","unshift","push","sweepRows","prevState","useInterval","callback","delay","savedCallback","useRef","current","interval","setInterval","clearInterval","Display","Button","button","tSS","GameOver","StyledDisplaysContainer","StyledDisplays","StyledControlsContainer","StyledControl","StyledTetrisContainer","tilt","gameOver","StyledSlider","input","OnScreenControls","onClick","e","onPushLeft","preventDefault","onPushRotate","onPushDown","onPushRight","Tetris","setTilt","dropTime","setDropTime","setGameOver","gamePaused","setGamePaused","gameStarted","setGameStarted","setPlayer","rotate","matrix","direction","rotatedTetromino","_","col","reverse","useCallback","clonedPlayer","JSON","parse","stringify","offset","usePlayer","updatePlayerPosition","playerRotate","score","setScore","rows","setRows","level","setLevel","linePoints","calcScore","useGameStatus","gameRef","movePlayer","dir","playerMovement","startGame","moveTetrominoDown","canMoveTo","tryToMoveTo","action","focus","ref","role","tabIndex","onKeyUp","keyCode","onKeyDown","event","console","log","move","name","onChange","target","parseInt","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b0ee0b08.chunk.js","sourcesContent":["export const tetrisConfig = {\n    stage: {\n        width: 10,\n        height: 20,\n        backgroundColor: '#FFF',\n        lineColor: '#BBB',\n        guideColor: 'rgba(0,0,0,.05)',\n    },\n    cell: {\n        size: 32,\n        spacing: 0,\n    },\n};\n","export type TetrominoShapeType = Array<Array<string | number>>;\n\nexport type TetrominoKeyType = 0 | \"I\" | \"J\" | \"L\" | \"O\" | \"S\" | \"T\" | \"Z\";\n\nexport type TetrominoType = {\n    shape: TetrominoShapeType;\n    color: string;\n}\n\nexport type TetrominosType = {\n    [key in TetrominoKeyType]: TetrominoType;\n};\n\nexport const TETROMINOS: TetrominosType = {\n    0: { shape: [[0]], color: '0, 0, 0' },\n    I: {\n        shape: [[0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0]],\n        color: '#9cdaff',\n    },\n    J: {\n        shape: [[0, 'J', 0], [0, 'J', 0], ['J', 'J', 0]],\n        color: '#c568a5',\n    },\n    L: {\n        shape: [[0, 'L', 0], [0, 'L', 0], [0, 'L', 'L']],\n        color: '#ffd265',\n    },\n    O: {\n        shape: [['O', 'O'], ['O', 'O']],\n        color: '#bcff7c',\n    },\n    S: {\n        shape: [[0, 'S', 'S'], ['S', 'S', 0], [0, 0, 0]],\n        color: '#cd94ff',\n    },\n    T: {\n        shape: [[0, 0, 0], ['T', 'T', 'T'], [0, 'T', 0]],\n        color: '#8aedeb',\n    },\n    Z: {\n        shape: [['Z', 'Z', 0], [0, 'Z', 'Z'], [0, 0, 0]],\n        color: '#dea6ec',\n    },\n};\n  \nexport const randomTetromino = () => {\n    const tetrominos = 'IJLOSTZ';\n    const randTetromino = tetrominos[Math.floor(Math.random() * tetrominos.length)];\n    return TETROMINOS[randTetromino as keyof TetrominosType];\n};","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../Config/tetrisConfig';\n\ntype PropsType = {\n    color: string;\n};\n\nconst handleFaceTransform = (face: string) => {\n    switch (face) {\n        case 'right':\n            return 'rotateY(90deg)';\n        case 'back':\n            return 'rotateY(180deg)';\n        case 'left':\n            return 'rotateY(-90deg)';\n        case 'top':\n            return 'rotateX(90deg)';\n        case 'bottom':\n            return 'rotateX(-90deg)';\n        default:\n        case 'front':\n            return 'rotateY(0deg)';\n    }\n};\n\nexport const StyledCube = styled.div<{ transparent?: boolean }>`\n    width: ${tetrisConfig.cell.size}px;\n    height: ${tetrisConfig.cell.size}px;\n    position: relative;\n    transform-style: preserve-3d;\n    transform: translateX(${tetrisConfig.cell.spacing / 2}px) translateY(${tetrisConfig.cell.spacing / 2}px)\n        translateZ(${tetrisConfig.cell.size}px);\n    transition: transform 1s;\n\n    ${({ transparent }) =>\n        !transparent &&\n        `\n        &::after {\n            content: '';\n            position: absolute;\n            width: ${tetrisConfig.cell.size}px;\n            height: ${tetrisConfig.cell.size}px;\n            background: rgba(0,0,0,.1);\n            box-shadow: 0 0 10px rgba(0,0,0,.1);\n            transform: translateZ(-${tetrisConfig.cell.size}px);\n        }\n    `}\n`;\n\nexport const StyledCubeFace = styled.div<{ face: string; color: string }>`\n    position: absolute;\n    width: ${tetrisConfig.cell.size - tetrisConfig.cell.spacing * 2}px;\n    height: ${tetrisConfig.cell.size - tetrisConfig.cell.spacing * 2}px;\n    background: ${({ color }) => color};\n    line-height: ${tetrisConfig.cell.size}px;\n    font-size: 40px;\n    font-weight: bold;\n    color: white;\n    text-align: center;\n    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1) inset;\n    transform: ${({ face }) =>\n        `${handleFaceTransform(face)} translateZ(${tetrisConfig.cell.size / 2 - tetrisConfig.cell.spacing}px)`};\n`;\n\nconst Cell: FC<PropsType> = props => {\n    if (props.color === 'transparent') {\n        return <StyledCube transparent />;\n    }\n\n    return (\n        <StyledCube>\n            <StyledCubeFace face=\"front\" color={props.color} />\n            <StyledCubeFace face=\"back\" color={props.color} />\n            <StyledCubeFace face=\"right\" color={props.color} />\n            <StyledCubeFace face=\"left\" color={props.color} />\n            <StyledCubeFace face=\"top\" color={props.color} />\n            <StyledCubeFace face=\"bottom\" color={props.color} />\n        </StyledCube>\n    );\n};\n\nexport default Cell;\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst StyledInstructions = styled.div`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: #000;\n    padding: 20px;\n`;\n\nconst Instructions = () => (\n    <StyledInstructions>\n        Keybindings:\n        <br />\n        <br />\n        Up = Rotate tetromino\n        <br />\n        <br />\n        Left = Move tetromino left one cell\n        <br />\n        <br />\n        Right = Move tetromino right one cell\n        <br />\n        <br />\n        Down = Move tetromino down one cell\n        <br />\n        <br />\n        PageDown or End = Move tetromino all the way down\n    </StyledInstructions>\n);\n\nexport default Instructions;\n","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../Config/tetrisConfig';\nimport { TETROMINOS, TetrominosType } from '../Config/tetrominos';\nimport { StageType } from '../gameHelpers';\nimport Cell, { StyledCube } from './Cell';\nimport Instructions from './Instructions';\n\nexport const StyledStage = styled.div<{ showInstructions: boolean; paused: boolean }>`\n    width: ${() => `${tetrisConfig.stage.width * tetrisConfig.cell.size}px`};\n    height: ${() => `${tetrisConfig.stage.height * tetrisConfig.cell.size}px`};\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: flex-end;\n    align-items: flex-end;\n    background: ${tetrisConfig.stage.backgroundColor};\n\n    ${({ showInstructions }) =>\n        !showInstructions &&\n        `\n        background-image: linear-gradient(${tetrisConfig.stage.lineColor} 1px, transparent 1px),\n            linear-gradient(90deg, ${tetrisConfig.stage.lineColor} 1px, transparent 1px);\n        background-size: ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px,\n            ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px;\n        background-position: -1px -1px, -1px -1px;\n    `}\n\n    box-shadow: 0 0 0 1px ${tetrisConfig.stage.lineColor} inset;\n    border: 2px solid #000;\n    border-radius: 8px;\n    position: relative;\n\n    ${StyledCube} {\n        box-shadow: none;\n        filter: ${({ paused }) => (paused ? 'blur(15px)' : 'none')};\n    }\n`;\n\nconst StyledPause = styled.div`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: #000;\n    padding: 20px;\n    font-size: 40px;\n`;\n\nconst StyledRow = styled.div`\n    display: flex;\n    height: ${tetrisConfig.cell.size}px;\n    width: 100%;\n`;\n\nconst StyledColumnGuide = styled.div<{ left: number; size: number; columnWidth: number }>`\n    position: absolute;\n    left: ${({ left, columnWidth }) => `${left * columnWidth}px`};\n    width: ${({ size, columnWidth }) => `${size * columnWidth}px`};\n    top: 0;\n    bottom: 0;\n    background: ${tetrisConfig.stage.guideColor};\n`;\n\ntype PropsType = {\n    stage: StageType;\n    paused: boolean;\n    showInstructions: boolean;\n    activeColumns: {\n        left: number;\n        size: number;\n    };\n};\n\nconst Stage: FC<PropsType> = props => {\n    return (\n        <StyledStage showInstructions={props.showInstructions} paused={props.paused}>\n            {props.showInstructions && <Instructions />}\n            {props.paused && <StyledPause>Paused</StyledPause>}\n            {props.activeColumns.size > 0 && (\n                <StyledColumnGuide {...props.activeColumns} columnWidth={tetrisConfig.cell.size} />\n            )}\n            {props.stage.map((row: Array<Array<any>>, rowIndex: number) => (\n                <StyledRow key={rowIndex}>\n                    {row.map(([type, state], index: number) => {\n                        return (\n                            <Cell\n                                key={rowIndex + index}\n                                color={type === 0 ? 'transparent' : TETROMINOS[type as keyof TetrominosType].color}\n                            />\n                        );\n                    })}\n                </StyledRow>\n            ))}\n        </StyledStage>\n    );\n};\n\nexport default Stage;\n","import { PlayerStateType } from './Hooks/usePlayer';\nimport { tetrisConfig } from './Config/tetrisConfig';\nimport { TetrominoShapeType } from './Config/tetrominos';\n\nexport type StageCellType = [TetrominoShapeType];\n\nexport type StageType = Array<Array<any>>;\n\nexport const createStage = (): StageType => {\n    const emptyStage = Array.from(Array(tetrisConfig.stage.height), () =>\n        new Array(tetrisConfig.stage.width).fill([0, 'clear']),\n    );\n\n    return emptyStage;\n};\n\nexport const checkCollision = (\n    player: PlayerStateType,\n    stage: StageType,\n    { x: moveX, y: moveY }: { x: number; y: number },\n) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n        for (let x = 0; x < player.tetromino[y].length; x += 1) {\n            // 1. Check that we're on an actual Tetromino cell\n            if (player.tetromino[y][x] !== 0) {\n                if (\n                    // 2. Check that our move is inside the game areas height (y)\n                    // We shouldn't go through the bottom of the play area\n                    !stage[y + player.pos.y + moveY] ||\n                    // 3. Check that our move is inside the game areas width (x)\n                    !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n                    // 4. Check that the cell wer'e moving to isn't set to clear\n                    stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear'\n                ) {\n                    return true;\n                }\n            }\n        }\n    }\n};\n","import { useCallback, useState } from 'react';\nimport { checkCollision, StageType } from '../gameHelpers';\nimport { tetrisConfig } from '../Config/tetrisConfig';\nimport { randomTetromino, TETROMINOS, TetrominoShapeType } from '../Config/tetrominos';\n\nexport type PositionType = {\n    x: number;\n    y: number;\n};\n\nexport type PlayerStateType = {\n    pos: PositionType;\n    tetromino: TetrominoShapeType;\n    collided: boolean;\n};\n\nexport type PlayerPositionType = PositionType & { collided: boolean };\n\nconst playerStartingState: PlayerStateType = {\n    pos: {\n        x: 0,\n        y: 0,\n    },\n    tetromino: TETROMINOS[0].shape,\n    collided: false,\n};\n\nexport const usePlayer = () => {\n    const [player, setPlayer] = useState(playerStartingState);\n\n    const rotate = (matrix: TetrominoShapeType, direction: number) => {\n        const rotatedTetromino = matrix.map((_, index) => matrix.map(col => col[index]));\n\n        if (direction > 0) return rotatedTetromino.map(row => row.reverse());\n\n        return rotatedTetromino.reverse();\n    };\n\n    const playerRotate = (stage: StageType, direction: number) => {\n        const clonedPlayer = JSON.parse(JSON.stringify(player));\n        clonedPlayer.tetromino = rotate(clonedPlayer.tetromino, direction);\n\n        const pos = clonedPlayer.pos.x;\n        let offset = 1;\n        while (checkCollision(clonedPlayer, stage, { x: 0, y: 0 })) {\n            clonedPlayer.pos.x += offset;\n            offset = -(offset + (offset > 0 ? 1 : -1));\n            if (offset > clonedPlayer.tetromino[0].length) {\n                rotate(clonedPlayer.tetromino, -direction);\n                clonedPlayer.pos.x = pos;\n                return;\n            }\n        }\n        setPlayer(clonedPlayer);\n    };\n\n    const updatePlayerPosition = ({ x, y, collided }: PlayerPositionType) => {\n        setPlayer(prev => ({\n            ...prev,\n            pos: {\n                x: (prev.pos.x += x),\n                y: (prev.pos.y += y),\n            },\n            collided,\n        }));\n    };\n\n    const resetPlayer = useCallback(() => {\n        setPlayer({\n            pos: {\n                x: tetrisConfig.stage.width / 2 - 2,\n                y: 0,\n            },\n            tetromino: randomTetromino().shape,\n            collided: false,\n        });\n    }, []);\n\n    return [player, updatePlayerPosition, resetPlayer, playerRotate] as const;\n};\n","import { useState, useEffect } from 'react';\nimport { createStage, StageType } from '../gameHelpers';\nimport { PlayerStateType } from './usePlayer';\n\nexport const useStage = (player: PlayerStateType, resetPlayer: any) => {\n    const [ stage, setStage ] = useState(createStage());\n    const [ rowsCleared, setRowsCleared ] = useState(0);\n    const [ activeColumns, setActiveColumns ] = useState({left: 0, size: 0});\n\n    useEffect(() => {\n        setRowsCleared(0);\n\n        const sweepRows = (newStage: StageType) => (\n            newStage.reduce((accumulator, row) => {\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\n                    setRowsCleared(prev => prev + 1);\n                    accumulator.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n\n                    return accumulator;\n                }\n\n                accumulator.push(row);\n\n                return accumulator;\n            }, [])\n        )\n\n        const updateStage = (prevStage: StageType): StageType => {\n            const newStage = prevStage.map(row => {\n                return row.map(cell => { return cell[1] === 'clear' ? [0, 'clear'] : cell })\n            });\n\n            const offsetArray = player.tetromino.map((row) => {\n                const indexes = row.map((cell, index) => {\n                    return cell !== 0 ? index + 1 : 0;\n                }).filter(index => index > 0);\n\n                if (indexes.length > 0) {\n                    return [Math.min(...indexes), Math.max(...indexes)];\n                }\n                \n                return [];\n            }).filter(cells => cells.length > 0).flat();\n\n            setActiveColumns({\n                left: player.pos.x + (Math.min(...offsetArray) - 1),\n                size: Math.max(...offsetArray) - Math.min(...offsetArray) + 1,\n            });\n\n            // draw the current tetromino\n            player.tetromino.forEach((row, y: number) => {\n                row.forEach((value: number | string, x: number) => {\n                    if (value !== 0) {\n                        const newY = y + player.pos.y;\n                        const newX = x + player.pos.x;\n\n                        //console.log(`newX: ${newX}, width: ${player.tetromino[0].length}`);\n\n                        newStage[newY][newX] = [\n                            value,\n                            player.collided ? 'merged' : 'clear',\n                        ];\n                    }\n                });\n            });\n\n            // check collisions\n            if (player.collided) {\n                resetPlayer();\n\n                return sweepRows(newStage);\n            }\n\n            return newStage;\n        }\n\n        setStage(prevState => updateStage(prevState));\n\n    }, [player, resetPlayer]);\n\n    return [ stage, setStage, rowsCleared, activeColumns ] as const;\n};","import { useEffect, useRef } from 'react';\n\nconst useInterval = (callback: Function, delay?: number | null) => {\n    const savedCallback = useRef<Function>(() => {});\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    });\n\n    useEffect(() => {\n        if (delay !== null) {\n        const interval = setInterval(() => savedCallback.current(), delay || 0);\n            return () => clearInterval(interval);\n        }\n\n        return undefined;\n    }, [delay]);\n};\n\nexport default useInterval;\n","import styled from 'styled-components';\n\nconst Display = styled.div`\n    font-family: 'Press Start 2P', cursive;\n    border: 2px solid #000;\n    border-radius: 8px;\n    line-height: 50px;\n    font-size: 20px;\n    background: #fff;\n    margin-top: 20px;\n    color: #000;\n    padding: 0 20px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nexport default Display;\n","import styled from 'styled-components';\n\nconst Button = styled.button`\n    outline: none;\n    border: 2px solid #000;\n    border-radius: 8px;\n    line-height: 25px;\n    font-size: 20px;\n    padding: 20px;\n    background: #FFF;\n    font-family: inherit;\n\n    &:hover {\n        cursor: pointer;\n        box-shadow: 0 0 20px rgba(0,0,0,.2);\n    }\n`;\n\nexport default Button;","import styled from 'styled-components';\n\n// tSS = Text Shadow Size\nconst tSS = '1vw';\n\nconst GameOver = styled.div`\n    position: fixed;\n    display: flex;\n    width: 100%;\n    height: 100%;\n    justify-content: center;\n    align-items: center;\n    z-index: 99;\n    color: #000;\n    font-size: 60px;\n    font-size: 8vw;\n    display: flex;\n    flex-flow: column wrap;\n    font-family: 'Press Start 2P', cursive;\n    text-shadow: ${tSS} ${tSS} 0 #fff, ${tSS} 0 0 #fff, 0 ${tSS} 0 #fff, -${tSS} ${tSS} 0 #fff, 00px 0 #fff,\n        0-${tSS} 0 #fff, ${tSS} -${tSS} 0 #fff, -${tSS} -${tSS} 0 #fff, 0 0 30px #000;\n`;\n\nexport default GameOver;\n","import styled from 'styled-components';\nimport { tetrisConfig } from '../Config/tetrisConfig';\nimport Display from './Display';\n\nexport const StyledDisplaysContainer = styled.div`\n    margin-right: 20px;\n    display: flex;\n    flex-flow: column wrap;\n    justify-content: flex-start;\n    align-items: stretch;\n`;\n\nexport const StyledDisplays = styled.div`\n    display: flex;\n    flex-flow: column wrap;\n`;\n\nexport const StyledControlsContainer = styled.div`\n    display: none;\n\n    @media (max-width: ${tetrisConfig.cell.size * tetrisConfig.stage.width + 300}px) {\n        display: flex;\n    }\n\n    position: fixed;\n    top: ${() => `${tetrisConfig.stage.height * tetrisConfig.cell.size - 50}px`};\n    height: 50px;\n    width: 100%;\n    z-index: 98;\n    justify-content: center;\n    align-items: stretch;\n`;\n\nexport const StyledControl = styled.button`\n    display: flex;\n    outline: none;\n    border: none;\n    padding: 0;\n    flex-grow: 1;\n    justify-content: center;\n    background: rgba(255, 255, 255, 0.5);\n    padding: 20px;\n`;\n\nexport const StyledTetrisContainer = styled.div<{ gameOver: boolean; tilt: number }>`\n    outline: none;\n    display: flex;\n    flex-flow: row nowrap;\n    transform-style: preserve-3d;\n    transform: rotateX(${({ tilt }) => `${tilt}deg`}) rotateY(0deg) translateZ(0px);\n    filter: ${({ gameOver }) => (gameOver ? 'blur(5px)' : 'none')};\n    font-family: 'Press Start 2P', cursive;\n\n    // desktop size\n    @media (min-width: ${tetrisConfig.cell.size * tetrisConfig.stage.width + 300}px) {\n        flex-flow: row nowrap;\n\n        ${StyledDisplaysContainer} {\n            width: 300px;\n        }\n    }\n\n    // mobile size\n    @media (max-width: ${tetrisConfig.cell.size * tetrisConfig.stage.width + 300}px) {\n        flex-flow: column nowrap;\n        justify-content: center;\n        align-items: center;\n        padding-top: 10px;\n\n        ${Display} {\n            font-size: 14px;\n            margin-top: 0;\n            padding: 8px;\n            line-height: 14px;\n            display: block;\n            border: 0;\n        }\n\n        ${StyledDisplaysContainer} {\n            margin: 0;\n            padding: 20px;\n            order: 2;\n\n            ${StyledDisplays} {\n                border: 2px solid #000;\n                border-radius: 8px;\n                flex-flow: row wrap;\n                margin: 10px 0;\n                background: #fff;\n            }\n        }\n    }\n`;\n\nexport const StyledSlider = styled.input`\n    width: 100%;\n`;\n","import React, { FC } from 'react';\nimport { StyledControl, StyledControlsContainer } from './Styles';\n\ntype PropsType = {\n    onPushLeft(): void;\n    onPushRight(): void;\n    onPushRotate(): void;\n    onPushDown(): void;\n};\n\nconst OnScreenControls: FC<PropsType> = props => (\n    <StyledControlsContainer>\n        <StyledControl\n            onClick={e => {\n                props.onPushLeft();\n                e.preventDefault();\n            }}\n        >\n            Left\n        </StyledControl>\n        <StyledControl\n            onClick={e => {\n                props.onPushRotate();\n                e.preventDefault();\n            }}\n        >\n            Rotate\n        </StyledControl>\n        <StyledControl\n            onClick={e => {\n                props.onPushDown();\n                e.preventDefault();\n            }}\n        >\n            Down\n        </StyledControl>\n        <StyledControl\n            onClick={e => {\n                props.onPushRight();\n                e.preventDefault();\n            }}\n        >\n            Right\n        </StyledControl>\n    </StyledControlsContainer>\n);\n\nexport default OnScreenControls;\n","import React, { useRef, useState } from 'react';\nimport Stage from './Stage';\nimport { usePlayer } from '../Hooks/usePlayer';\nimport { useStage } from '../Hooks/useStage';\nimport useInterval from '../Hooks/useInterval';\nimport { createStage, checkCollision } from '../gameHelpers';\nimport { useGameStatus } from '../Hooks/useGameStatus';\nimport Display from './Display';\nimport { tetrisConfig } from '../Config/tetrisConfig';\nimport Button from './Button';\nimport GameOver from './GameOver';\nimport { StyledTetrisContainer, StyledDisplaysContainer, StyledDisplays, StyledSlider } from './Styles';\nimport OnScreenControls from './OnScreenControls';\n\ntype PlayerMovementType = 'LEFT' | 'RIGHT' | 'ROTATE' | 'DOWN' | 'FULLDOWN' | 'TOGGLE_PAUSE' | 'UNPAUSE';\n\nconst Tetris = () => {\n    const [tilt, setTilt] = useState(0);\n    const [dropTime, setDropTime] = useState<null | number>(null);\n    const [gameOver, setGameOver] = useState(false);\n    const [gamePaused, setGamePaused] = useState(false);\n    const [gameStarted, setGameStarted] = useState(false);\n    const [player, updatePlayerPosition, resetPlayer, playerRotate] = usePlayer();\n    const [stage, setStage, rowsCleared, activeColumns] = useStage(player, resetPlayer);\n    const [score, setScore, rows, setRows, level, setLevel] = useGameStatus(rowsCleared);\n    const gameRef = useRef<HTMLDivElement>(null);\n\n    const movePlayer = (dir: number) => {\n        playerMovement('UNPAUSE');\n        if (!checkCollision(player, stage, { x: dir, y: 0 })) {\n            updatePlayerPosition({ x: dir, y: 0, collided: false });\n        }\n    };\n\n    const startGame = () => {\n        setStage(createStage());\n        setDropTime(1000);\n        resetPlayer();\n        setScore(0);\n        setLevel(0);\n        setRows(0);\n        setGameOver(false);\n        setGameStarted(true);\n    };\n\n    const moveTetrominoDown = (y: number) => {\n        // Increase level and speed when player has cleared 10 rows\n        if (rows > (level + 1) * 10) {\n            setLevel(prev => prev + 1);\n            setDropTime(1000 / (level + 1) + 200);\n        }\n\n        // Check how far we can move without colliding\n        let canMoveTo = 0;\n\n        for (let tryToMoveTo = 1; tryToMoveTo <= y; tryToMoveTo += 1) {\n            if (checkCollision(player, stage, { x: 0, y: tryToMoveTo })) {\n                break;\n            } else {\n                canMoveTo = tryToMoveTo;\n            }\n        }\n\n        // debug collision detection\n        //console.log(`want to move to: ${y}, canMove to ${canMoveTo}, collidesAt ${collideAt}.`);\n\n        if (canMoveTo === y) {\n            updatePlayerPosition({ x: 0, y: y, collided: false });\n        } else {\n            if (player.pos.y < 1) {\n                setGameStarted(false);\n                setGameOver(true);\n                setDropTime(null);\n            }\n            updatePlayerPosition({ x: 0, y: canMoveTo, collided: true });\n        }\n    };\n\n    const keyUp = ({ keyCode }: { keyCode: number }) => {\n        if (!gameOver) {\n            if (keyCode === 40 || keyCode === 34 || keyCode === 35) {\n                playerMovement('UNPAUSE');\n            }\n        }\n    };\n\n    const playerMovement = (action: PlayerMovementType) => {\n        switch (action) {\n            case 'LEFT':\n                movePlayer(-1);\n                break;\n            case 'RIGHT':\n                movePlayer(1);\n                break;\n            case 'DOWN':\n                setDropTime(null);\n                moveTetrominoDown(1);\n                break;\n            case 'FULLDOWN':\n                setDropTime(null);\n                moveTetrominoDown(tetrisConfig.stage.height);\n                break;\n            case 'ROTATE':\n                playerRotate(stage, 1);\n                break;\n            case 'TOGGLE_PAUSE':\n                if (gamePaused) {\n                    setGamePaused(false);\n                    setDropTime(1000 / (level + 1));\n                } else {\n                    setGamePaused(true);\n                    setDropTime(null);\n                }\n                break;\n            case 'UNPAUSE':\n                setGamePaused(false);\n                setDropTime(1000 / (level + 1));\n                break;\n        }\n    };\n\n    const move = (event: React.KeyboardEvent<HTMLDivElement>) => {\n        let preventDefault = true;\n\n        if (!gameOver) {\n            switch (event.keyCode) {\n                case 37: // LEFT\n                    playerMovement('LEFT');\n                    break;\n                case 39: // RIGHT\n                    playerMovement('RIGHT');\n                    break;\n                case 40: // DOWN\n                    playerMovement('DOWN');\n                    break;\n                case 38: // UP\n                    playerMovement('ROTATE');\n                    break;\n                case 80: // P\n                    playerMovement('TOGGLE_PAUSE');\n                    break;\n                case 34: // Page Down\n                case 35: // End\n                    playerMovement('FULLDOWN');\n                    break;\n                default:\n                    console.log(`Unused keystroke: ${event.keyCode}`);\n                    preventDefault = false;\n                    break;\n            }\n        }\n\n        if (preventDefault) {\n            event.preventDefault();\n        }\n    };\n\n    useInterval(() => {\n        moveTetrominoDown(1);\n    }, dropTime);\n\n    return (\n        <>\n            {gameOver && (\n                <GameOver>\n                    <p>Game Over</p>\n                    <Button\n                        onClick={() => {\n                            startGame();\n                            gameRef?.current?.focus();\n                        }}\n                    >\n                        Restart Game\n                    </Button>\n                </GameOver>\n            )}\n            <OnScreenControls\n                onPushLeft={() => {\n                    playerMovement('LEFT');\n                }}\n                onPushRotate={() => {\n                    playerMovement('ROTATE');\n                }}\n                onPushRight={() => {\n                    playerMovement('RIGHT');\n                }}\n                onPushDown={() => {\n                    playerMovement('DOWN');\n                }}\n            />\n            <StyledTetrisContainer\n                ref={gameRef}\n                tilt={tilt}\n                gameOver={gameOver}\n                role=\"button\"\n                tabIndex={0}\n                onKeyUp={keyUp}\n                onKeyDown={event => {\n                    move(event);\n                }}\n            >\n                <StyledDisplaysContainer>\n                    {!gameStarted ? (\n                        <Button\n                            onClick={() => {\n                                startGame();\n                            }}\n                        >\n                            Start Game\n                        </Button>\n                    ) : (\n                        <Button\n                            onClick={() => {\n                                playerMovement('TOGGLE_PAUSE');\n                            }}\n                        >\n                            {gamePaused ? 'Continue...' : 'Pause Game'}\n                        </Button>\n                    )}\n                    <StyledDisplays>\n                        <Display>Score: {score}</Display>\n                        <Display>Rows: {rows}</Display>\n                        <Display>Level: {level}</Display>\n                        <Display>\n                            Tilt:\n                            <StyledSlider\n                                type=\"range\"\n                                name=\"volume\"\n                                value={tilt}\n                                min=\"0\"\n                                max=\"45\"\n                                onChange={({ target }) => {\n                                    setTilt(parseInt(target.value));\n                                }}\n                            />\n                        </Display>\n                    </StyledDisplays>\n                </StyledDisplaysContainer>\n                <Stage\n                    paused={gamePaused}\n                    stage={stage}\n                    showInstructions={!gameStarted}\n                    activeColumns={activeColumns}\n                />\n            </StyledTetrisContainer>\n        </>\n    );\n};\n\nexport default Tetris;\n","import { useState, useEffect, useCallback } from 'react';\n\nexport const useGameStatus = (rowsCleared: number) => {\n    const [score, setScore] = useState(0);\n    const [rows, setRows] = useState(0);\n    const [level, setLevel] = useState(0);\n\n    const linePoints = [40, 100, 300, 1200];\n\n    const calcScore = useCallback(() => {\n        if (rowsCleared > 0) {\n            // This is how original Tetris score is calculated\n            setScore(prev => prev + linePoints[rowsCleared - 1] * (level + 1));\n            setRows(prev => prev + rowsCleared);\n        }\n    }, [level, linePoints, rowsCleared]);\n\n    useEffect(() => {\n        calcScore();\n    }, [calcScore, rowsCleared, score]);\n\n    return [score, setScore, rows, setRows, level, setLevel] as const;\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Tetris from './Components/Tetris';\n\nReactDOM.render(<Tetris />, document.getElementById('tetris'));\n"],"sourceRoot":""}
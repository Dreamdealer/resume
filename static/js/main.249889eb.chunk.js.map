{"version":3,"sources":["tetrisConfig.ts","tetrominos.ts","Components/Cell.tsx","Components/Stage.tsx","gameHelpers.ts","Hooks/usePlayer.ts","Hooks/useStage.ts","Hooks/useInterval.ts","Components/Tetris.tsx","App.tsx","index.tsx"],"names":["tetrisConfig","width","height","backgroundColor","lineColor","size","spacing","TETROMINOS","0","shape","color","I","J","L","O","S","T","Z","randomTetromino","tetrominos","randTetromino","Math","floor","random","length","StyledCube","styled","div","transparent","StyledCubeFace","face","handleFaceTransform","Cell","props","StyledStage","StyledRow","Stage","stage","map","row","rowIndex","index","type","createStage","Array","from","fill","checkCollision","player","moveX","x","moveY","y","tetromino","pos","playerStartingState","collided","useStage","resetPlayer","useState","setStage","rowsCleared","setRowsCleared","useEffect","updateStage","prevStage","newStage","cell","forEach","value","newY","newX","reduce","accumulator","findIndex","prev","unshift","push","sweepRows","prevState","useInterval","callback","delay","savedCallback","useRef","current","interval","setInterval","clearInterval","StyledTetrisContainer","Tetris","dropTime","setDropTime","gameOver","setGameOver","setPlayer","rotate","matrix","direction","rotatedTetromino","_","col","reverse","useCallback","clonedPlayer","JSON","parse","stringify","offset","usePlayer","updatePlayerPosition","playerRotate","movePlayer","dir","drop","console","log","move","keyCode","role","tabIndex","onKeyUp","onKeyDown","event","preventDefault","onClick","StyledApp","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.249889eb.chunk.js","sourcesContent":["export const tetrisConfig = {\n    stage: {\n        width: 12,\n        height: 16,\n        backgroundColor: 'transparent',\n        lineColor: '#000',\n    },\n    cell: {\n        size: 38,\n        spacing: 0,\n    }\n}","export type TetrominoShapeType = Array<Array<string | number>>;\n\nexport type TetrominoKeyType = 0 | \"I\" | \"J\" | \"L\" | \"O\" | \"S\" | \"T\" | \"Z\";\n\nexport type TetrominoType = {\n    shape: TetrominoShapeType;\n    color: string;\n}\n\nexport type TetrominosType = {\n    [key in TetrominoKeyType]: TetrominoType;\n};\n\nexport const TETROMINOS: TetrominosType = {\n    0: { shape: [[0]], color: '0, 0, 0' },\n    I: {\n        shape: [[0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0]],\n        color: '#EBA83A',\n    },\n    J: {\n        shape: [[0, 'J', 0], [0, 'J', 0], ['J', 'J', 0]],\n        color: '#E4BAD4',\n    },\n    L: {\n        shape: [[0, 'L', 0], [0, 'L', 0], [0, 'L', 'L']],\n        color: '#FFC074',\n    },\n    O: {\n        shape: [['O', 'O'], ['O', 'O']],\n        color: '#FAEBE0',\n    },\n    S: {\n        shape: [[0, 'S', 'S'], ['S', 'S', 0], [0, 0, 0]],\n        color: '#F7E6AD',\n    },\n    T: {\n        shape: [[0, 0, 0], ['T', 'T', 'T'], [0, 'T', 0]],\n        color: '#C9D8B6',\n    },\n    Z: {\n        shape: [['Z', 'Z', 0], [0, 'Z', 'Z'], [0, 0, 0]],\n        color: '#F1ECC3',\n    },\n};\n  \nexport const randomTetromino = () => {\n    const tetrominos = 'IJLOSTZ';\n    const randTetromino = tetrominos[Math.floor(Math.random() * tetrominos.length)];\n    return TETROMINOS[randTetromino as keyof TetrominosType];\n};","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../tetrisConfig';\n\ntype PropsType = {\n    color: string;\n}\n\nconst handleFaceTransform = (face: string) => {\n    switch (face) {\n        case \"right\": return 'rotateY(90deg)';\n        case \"back\": return 'rotateY(180deg)';\n        case \"left\": return 'rotateY(-90deg)';\n        case \"top\": return 'rotateX(90deg)';\n        case \"bottom\": return 'rotateX(-90deg)';\n        default: case \"front\": return 'rotateY(0deg)';\n    }\n};\n\nconst StyledCube = styled.div<{ transparent?: boolean }>`\n    width: ${tetrisConfig.cell.size}px;\n    height: ${tetrisConfig.cell.size}px;\n    position: relative;\n    transform-style: preserve-3d;\n    transform:  translateX(${tetrisConfig.cell.spacing / 2}px) translateY(${tetrisConfig.cell.spacing / 2}px) translateZ(${tetrisConfig.cell.size}px);\n    transition: transform 1s;\n    \n    ${({transparent}) => !transparent && `\n        &::after {\n            content: '';\n            position: absolute;\n            width: ${tetrisConfig.cell.size}px;\n            height: ${tetrisConfig.cell.size}px;\n            background: rgba(0,0,0,.1);\n            box-shadow: 0 0 10px rgba(0,0,0,.1);\n            transform: translateZ(-${tetrisConfig.cell.size}px);\n        }\n    `}\n`\n\nconst StyledCubeFace = styled.div<{ face: string; color: string; }>`\n    position: absolute;\n    width: ${tetrisConfig.cell.size - (tetrisConfig.cell.spacing * 2)}px;\n    height: ${tetrisConfig.cell.size - (tetrisConfig.cell.spacing * 2)}px;\n    background: ${({color}) => color};\n    line-height: ${tetrisConfig.cell.size}px;\n    font-size: 40px;\n    font-weight: bold;\n    color: white;\n    text-align: center;\n    box-shadow: 0 0 0 1px rgba(0,0,0,.1) inset;\n    transform: ${({ face }) => `${handleFaceTransform(face)} translateZ(${(tetrisConfig.cell.size / 2) - (tetrisConfig.cell.spacing)}px)`};\n`;\n\nconst Cell:FC<PropsType> = props => {\n    if (props.color === 'transparent') {\n        return <StyledCube transparent />\n    }\n\n    return (\n        <StyledCube>\n            <StyledCubeFace face=\"front\" color={props.color} />\n            <StyledCubeFace face=\"back\" color={props.color} />\n            <StyledCubeFace face=\"right\" color={props.color} />\n            <StyledCubeFace face=\"left\" color={props.color} />\n            <StyledCubeFace face=\"top\" color={props.color} />\n            <StyledCubeFace face=\"bottom\" color={props.color} />\n        </StyledCube>\n    )\n}\n\nexport default Cell;","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { tetrisConfig } from '../tetrisConfig';\nimport { TETROMINOS, TetrominosType } from '../tetrominos';\nimport Cell from './Cell';\n\nconst StyledStage = styled.div`\n    width: ${() => `${tetrisConfig.stage.width * tetrisConfig.cell.size}px`};\n    height: ${() => `${tetrisConfig.stage.height * tetrisConfig.cell.size}px`};\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: flex-end;\n    align-items: flex-end;\n    transform-style: preserve-3d;\n    transform: rotateX(35deg) rotateY(0deg) translateZ(100px);\n    background: ${tetrisConfig.stage.backgroundColor};\n    background-image: \n        linear-gradient(${tetrisConfig.stage.lineColor} 1px, transparent 1px),\n        linear-gradient(90deg, ${tetrisConfig.stage.lineColor} 1px, transparent 1px);\n    background-size: ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px, ${tetrisConfig.cell.size}px ${tetrisConfig.cell.size}px;\n    background-position: -1px -1px, -1px -1px;\n    box-shadow: 0 0 0 1px ${tetrisConfig.stage.lineColor} inset;\n`\n\nconst StyledRow = styled.div`\n    display: flex;\n    height: ${tetrisConfig.cell.size}px;\n    width: 100%;\n`;\n\ntype PropsType = {\n    stage: any;\n}\n\nconst Stage:FC<PropsType> = props => {\n    return (\n        <StyledStage>\n            {props.stage.map((row: Array<Array<any>>, rowIndex: number) => (\n                <StyledRow key={rowIndex}>\n                    {row.map(([type, state], index: number) => {\n                        return <Cell key={rowIndex + index} color={type === 0 ? \"transparent\": TETROMINOS[type as keyof TetrominosType].color} />\n                    })}\n                </StyledRow>\n            ))}\n        </StyledStage>\n    )\n}\n\nexport default Stage;","import { tetrisConfig } from './tetrisConfig';\nimport { TetrominoShapeType } from './tetrominos';\n\nexport type StageCellType = [ TetrominoShapeType]\n\nexport type StageType = Array<Array<any>>;\n\nexport const createStage = (): StageType => {\n    const emptyStage = Array.from(Array(tetrisConfig.stage.height), () =>\n            new Array(tetrisConfig.stage.width).fill([0, 'clear']),\n    );\n\n    return emptyStage;\n}\n\nexport const checkCollision = (player: any, stage: any, { x: moveX, y: moveY }: { x: number, y: number}) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // We shouldn't go through the bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n          // 4. Check that the cell wer'e moving to isn't set to clear\n          stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n            'clear'\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n};","import { useCallback, useState } from 'react';\nimport { checkCollision, StageType } from '../gameHelpers';\nimport { tetrisConfig } from '../tetrisConfig';\nimport { randomTetromino, TETROMINOS, TetrominoShapeType } from '../tetrominos';\n\nexport type PositionType = { \n    x: number; \n    y: number;\n}\n\nexport type PlayerStateType = {\n    pos: PositionType;\n    tetromino: TetrominoShapeType;\n    collided: boolean;\n}\n\nexport type PlayerPositionType = PositionType & { collided: boolean; }\n\nconst playerStartingState: PlayerStateType = {\n    pos: { \n        x: 0, \n        y: 0 \n    },\n    tetromino: TETROMINOS[0].shape,\n    collided: false,\n};\n\nexport const usePlayer = () => {\n    const [ player, setPlayer ] = useState(playerStartingState);\n\n    const rotate = (matrix: TetrominoShapeType, direction: number) => {\n        const rotatedTetromino = matrix.map((_, index) => \n            matrix.map(col => col[index]),\n        );\n\n        if (direction > 0) return rotatedTetromino.map(row => row.reverse());\n\n        return rotatedTetromino.reverse();\n    }\n\n    const playerRotate = (stage: StageType, direction: number) => {\n        const clonedPlayer = JSON.parse(JSON.stringify(player));\n        clonedPlayer.tetromino = rotate(clonedPlayer.tetromino, direction);\n\n        const pos = clonedPlayer.pos.x;\n        let offset = 1;\n        while (checkCollision(clonedPlayer, stage, { x: 0, y: 0 })) {\n            clonedPlayer.pos.x += offset;\n            offset = -(offset + (offset > 0 ? 1 : -1));\n            if (offset > clonedPlayer.tetromino[0].length) {\n                rotate(clonedPlayer.tetromino, -direction);\n                clonedPlayer.pos.x = pos;\n                return;\n            }\n        }\n        setPlayer(clonedPlayer);\n    }\n\n    const updatePlayerPosition = ({ x, y, collided} : PlayerPositionType) => {\n        setPlayer(prev => ({\n            ...prev,\n            pos: { \n                x: prev.pos.x += x, \n                y: prev.pos.y += y \n            },\n            collided,\n        }))\n    }\n\n    const resetPlayer = useCallback(() => {\n        setPlayer({\n            pos: { \n                x: (tetrisConfig.stage.width / 2) - 2, \n                y: 0 \n            },\n            tetromino: randomTetromino().shape,\n            collided: false, \n        })\n    }, []);\n\n    return [ player, updatePlayerPosition, resetPlayer, playerRotate ] as const;\n}","import { useState, useEffect } from 'react';\nimport { createStage, StageType } from '../gameHelpers';\nimport { PlayerStateType } from './usePlayer';\n\nexport const useStage = (player: PlayerStateType, resetPlayer: any) => {\n    const [ stage, setStage ] = useState(createStage());\n    const [ rowsCleared, setRowsCleared ] = useState(0);\n\n    useEffect(() => {\n        setRowsCleared(0);\n\n        const sweepRows = (newStage: StageType) => (\n            newStage.reduce((accumulator, row) => {\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\n                    setRowsCleared(prev => prev + 1);\n                    accumulator.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n\n                    return accumulator;\n                }\n\n                accumulator.push(row);\n\n                return accumulator;\n            }, [])\n        )\n\n        const updateStage = (prevStage: StageType): StageType => {\n            const newStage = prevStage.map(row => {\n                return row.map(cell => { return cell[1] === 'clear' ? [0, 'clear'] : cell })\n            });\n\n            // draw the current tetromino\n            player.tetromino.forEach((row, y: number) => {\n                row.forEach((value: number | string, x: number) => {\n                    if (value !== 0) {\n                        const newY = y + player.pos.y;\n                        const newX = x + player.pos.x;\n\n                        newStage[newY][newX] = [\n                            value,\n                            player.collided ? 'merged' : 'clear',\n                        ];\n                    }\n                });\n            });\n\n            // check collisions\n            if (player.collided) {\n                resetPlayer();\n\n                return sweepRows(newStage);\n            }\n\n            return newStage;\n        }\n\n        setStage(prevState => updateStage(prevState));\n\n    }, [player, resetPlayer]);\n\n    return [ stage, setStage, rowsCleared ] as const;\n};","import { useEffect, useRef } from 'react';\n\nconst useInterval = (callback: Function, delay?: number | null) => {\n    const savedCallback = useRef<Function>(() => {});\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    });\n\n    useEffect(() => {\n        if (delay !== null) {\n        const interval = setInterval(() => savedCallback.current(), delay || 0);\n            return () => clearInterval(interval);\n        }\n\n        return undefined;\n    }, [delay]);\n};\n\nexport default useInterval;\n","import React, { useState } from 'react';\nimport Stage from './Stage';\nimport { usePlayer } from '../Hooks/usePlayer';\nimport { useStage } from '../Hooks/useStage';\nimport useInterval from '../Hooks/useInterval';\nimport styled from 'styled-components';\nimport { createStage, checkCollision } from '../gameHelpers';\n\nconst StyledTetrisContainer = styled.div`\n    height: 100vh;\n    outline: none;\n`;\n\nconst Tetris = () => {\n    const [ dropTime, setDropTime ] = useState<null | number>(null);\n    const [ gameOver, setGameOver ] = useState(false);\n    const [ player, updatePlayerPosition, resetPlayer, playerRotate ] = usePlayer();\n    const [ stage, setStage ] = useStage(player, resetPlayer);\n    \n    const movePlayer = (dir: number) => {\n        if (!checkCollision(player, stage, { x: dir, y: 0 })) {\n            updatePlayerPosition({ x: dir, y: 0, collided: false });\n        }\n    }\n\n    const startGame = () => {\n        setStage(createStage());\n        setDropTime(1000);\n        resetPlayer();\n        setGameOver(false);\n    }\n\n    const drop = () => {\n        if (!checkCollision(player, stage, { x: 0, y: 1 })) {\n            updatePlayerPosition({ x: 0, y: 1, collided: false });\n        } else {\n            if (player.pos.y < 1) {\n                console.log('GAME OVER');\n                setGameOver(true);\n                setDropTime(null);\n            }\n            updatePlayerPosition({ x: 0, y: 0, collided: true });\n        }\n    }\n\n    const keyUp = ({ keyCode }: { keyCode: number}) => {\n        if (!gameOver && keyCode === 40) {\n            setDropTime(1000);\n        }\n    }\n\n    const dropPlayer = () => {\n        setDropTime(null);\n        drop(); \n    }\n\n    const move = ({ keyCode } : { keyCode: number}) => {\n        if (!gameOver) {\n            switch (keyCode) {\n                case 37: movePlayer(-1); break;\n                case 39: movePlayer(1); break;\n                case 40: dropPlayer(); break;\n                case 38: playerRotate(stage, 1); break;\n            }\n        }\n    }\n\n    useInterval(() => {\n        drop();\n    }, dropTime);\n\n    return (\n        <StyledTetrisContainer role=\"button\" tabIndex={0} onKeyUp={keyUp} onKeyDown={event => { \n            move(event); \n            event.preventDefault(); \n        }}>\n            <button onClick={() => { startGame(); }}>Start Game</button>\n            <Stage stage={stage} />\n        </StyledTetrisContainer>\n    )\n}\n\nexport default Tetris;\n","import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport Tetris from './Components/Tetris';\n\nconst StyledApp = styled.div`\n    margin: 0;\n    font-family: 'Segoe UI', sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    color: #db7093;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    perspective: 1000px;\n`;\n\nconst StyledHeader = styled.div`\n    font-size: calc(10px + 2vmin);\n`;\n\nconst App:FC = () => {\n  return (\n    <StyledApp>\n      <Tetris />\n    </StyledApp>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App />,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}